第九天:最长标示匹配





Perl6 正则表达式偏好尽可能的匹配最长的选择。
say "food and drink" ~~ / foo | food /;   # food

这跟 Perl5 不一样。Perl5 更喜欢上面例子中的第一个选择，结果匹配的是 "foo" 。

如果你希望的话，你依然可以按照优先匹配的原则运行，这个原则隐藏在稍长选择操作符 || 背后：
say "food and drink" ~~ / foo || food /;  # foo

...就是这样。这就是最长标记匹配。 ☺ 短文完毕。

“喂，等等！”你听见你绝望而惊讶的大叫了，满足你希望让每天的 Perl6 圣临历走的慢一点的愿望。“为什么说最长标记匹配很重要？谁会在意这个？”

我很高兴你这样问。事实证明，最长标记匹配（简称 LTM ）在如何解析的时候和我们的直觉配合相当默契。如果你创造了一门语言，你希望人们可以声明一个叫 forest_density 的变量而不用提及这个单词和循环里用的 for 语法冲突，LTM 可以做到。

我喜欢“奇怪的一致性”这个说法 -- 尤其当程序语言设计的共性让大家越来越雷同的时候。这里就是一种在类和语法之间的一致性。 Perl6 基本上把这种一致性发挥到了极致。让我简单的阐述下我的意思。

现在我们习惯于写一个类，总体来看，类差不多是长这个样子的：

class {
    method
    method
    method
}

奇怪的是，语法有个非常类似的结构：

grammar {
    rule
    rule
    rule
}

（实际上关键词有 regex ， token 和 rule ，不过当我们把他当作一个组来讨论的时候，我们暂时统一叫做 rules ）

我们同样习惯于派生子类（ class B is A ），然后添加或者重写方法来产生一个新旧行为在一起的组合。Pelr6 提供了 multi methods ，它允许你添加相同名字的新方法，而且不重写原有的，它只尝试匹配所有的到新方法而已。这个调度是由一个（通常自动生成的） proto method 处理的。它负责调度给所有合格的候选者。

这些是怎样用语法和角色运行起来的呢？额，首先它从原有的里面派生出新的语法，和派生子类一样。（事实上，底层是 完全 相同的机制。语法不过是有个不同元类对象的类罢了。）新的角色也会重写原有的角色，和你在方法上习惯的一样。

S05 有个漂亮的解析信件的示例。然后派生出来解析正式信件的语法：

     grammar Letter {
         rule text     {    }
         rule greet { [Hi|Hey|Yo] $=(\S+?) , $$}
         rule body     { +? }   # note: backtracks forwards via +?
         rule close { Later dude, $=(.+) }
     }
 
     grammar FormalLetter is Letter {
         rule greet { Dear $=(\S+?) , $$}
         rule close { Yours sincerely, $=(.+) }
     }

派生出来的 FormalLetter 重写了 greet 和 close ，但是没重写 body 。

但是这一切在 multi 方法下也能正常运行吗？我们是不是可以定义一种“原型角色”来允许我们在一个语法里用同样的名字有多种角色，内容各不相同？比如，我们可能希望用一个角色 term 来解析语言，不过有很多不同的 terms：字符串、数字……而且数字可能是十进制、二进制、八进制、十六进制等……

Perl6 语法可以包含一个原型角色，然后你可以定义、重定义同名角色随便多少次。显然让我们回到文章最开始的 / foo | food / 。所有你起了相同名字的角色会编译成一个大的 alternation（译者注：轮流选择，不确定怎么翻译更好）。不仅如此 -- 调用其他角色的角色，有些可能是原型角色，这些也会全部扁平化到一个大的 LTM 轮流选择里。实践中，这意味着一个 term 的所有可能会一次被全部尝试一遍，机会平等。没哪个会因为自己是先定义的所以胜出，只有最长匹配的那个选择才胜出。

这个奇怪的一致性说明事实上，在调用某个方式的时候，最具体的方法胜出，而且这个“最具体”必须加上引号。签名里参数描述类型越好，方法就越具体。

在分析某个角色的时候，同样是最具体的角色胜出，不过这里“最具体”必须成功解析才行。角色描述下一步进入的文本越详细，角色就越具体。

这就是奇怪的一致性。因为表面上方法和角色看起来就是完全不一样的怪兽。

我们真心相信我们理解了派生语法的原理并且得到了一门新的语言。 LTM 就是最合适的因为它允许新旧角色通过一个公平和可预测的办法混杂在一起。角色不是因为他们定义的前后而胜出，而是因为它能最好的解析文本。这才是挑选精英的办法。

事实上，Perl6 编译器自己就是这样工作的。它使用 Perl6 语法解析你的程序，这个语法是可以派生的……不管你在程序里什么时候声明了一个新操作符，都会给你派生出一个新的语法。新操作符的解析就作为新角色加入到新语法里。然后把解析剩余程序的任务交给新的语法。你的新操作符会胜过那写相同但匹配更短的，不过输给相同但匹配更长的。

来源： < https://github.com/sxw2k/perl6advent_cn/blob/master/chinese/2012/%E7%AC%AC%E4%B9%9D%E5%A4%A9:%E6%9C%80%E9%95%BF%E6%A0%87%E7%A4%BA%E5%8C%B9%E9%85%8D.markdown >  