

对编译器的传统优化主要依赖于编程时对编译期的知识掌握。通常静态语言比如java和C都比较擅长这个，而动态语言像Perl5和ruby、python则相反。

Perl6提供和动态语言一样的灵活性，但也尝试提供一定的编译器优化，虽然是靠敲键盘写明可选的静态类型注释。

但即便你标明了静态类型，编译期内还有一块需要编译器调度和内联的：关于可用例程的认知（以及在多函数multi subs时提供候选）。

为了提供这个认知，Perl6在词法作用域内（而不在包和符号表内，这和Perl5一样）部署子例程。而词法作用域在运行时间内是不可变的。（词法作用域内的变量当然 还是可变的，你只是不能添加或者删除作用域内的条目）

为了提供足够的灵活性，Perl6允许在编译期运行代码。一个典型的在编译期运行代码的办法就是跟use指令写在一块：

{
    use Test;  # 在编译期把例程导入一个正确的词法作用域
    plan 1;
    ok 1, 'success';
}
# 跳出作用域，plan()和ok()现在已经失效了

这么做的好处，是一个聪明可爱的编译器可以在运行期之前就检查成缺少例程，然后认定这个程序注定会失败。目前Rakudo就可以做到这点，虽然已知有一个情况Raku do不会检测，但是我确信这个是可以检测的。

sub f(Int $x) {
    say $x * 2;
}
say "got here";
f('some string');

Rakudo运行这个代码会得到如下输出：

===SORRY!===
CHECK FAILED:
Calling 'f' will never work with argument types (str) (line 5)
    Expected: :(Int $x)

因为内置例程是在更外一层的作用域里提供给用户程序的，所有的内置例程都和用户自定义例程接受同样的规则和优化。

注意：这里牵扯到另一个东西-- require。require是在运行期加载模块的，但现在它需要在编译期保存一个符号表的列表。这样在之后才可以连接上那些从模块里加载上的符号表。

关于"聪明可爱的编译器"的空想时代已经过去，现在我们已经拥有一个提供可测量的加速效果的编译器。当然它依然还有提升的空间，而我们已经可以看到静态认知和词法作用 域的好处了！

来源： < https://github.com/sxw2k/perl6advent_cn/blob/master/chinese/2011/%E7%AC%AC%E5%85%AB%E5%A4%A9:%E8%AF%8D%E6%B3%95%E5%92%8C%E4%BC%98%E5%8C%96.markdown >  