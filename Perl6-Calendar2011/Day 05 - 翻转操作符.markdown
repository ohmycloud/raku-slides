

Perl5里有一个二进制操作符叫翻转(flip-flop，译者注：因为在perl5里已经存在，但是我依然没有找到相应的中文翻译，下文也会照惯例使用英文了)。 这个操作符的返回值为假，直到第一个参数为真的时候他也flip成真，然后持续到第二个参数为真的时候，又flop成假。这个操作符蛮有用的，所以Perl6也保留了 下来，不过改写成ff，还有了几个变种：

ff

ff^

^ff

^ff^

^符号的意思，就是在端点处跳过端点的值。

好吧，可能举个例子可能更明白些：

    for 1..20 { .say if $_ == 9  ff  $_ == 13; }     # 9 10 11 12 13
    for 1..20 { .say if $_ == 9  ff^ $_ == 13; }     # 9 10 11 12
    for 1..20 { .say if $_ == 9 ^ff  $_ == 13; }     #   10 11 12 13
    for 1..20 { .say if $_ == 9 ^ff^ $_ == 13; }     #   10 11 12

例子里我们迭代一个从1到20的范围，并且在flip-flop操作符返回为真的时候输出这些数。操作符两端都是9和13（我这里简单的使用了数值 ，但是实际上任何布尔值表达式都可以用在flip-flop操作符上）。

每个flip-flop操作的实例都维护着一个自己的内部状态，用以决定什么时候返回真，什么时候返回假。所有的flip- flop操作符在诞生的时候都是默认为返回假并且等待他们被flip成返回真的那一刻。

在前两个例子里，当$_ == 9的时候，flip-flop被翻成真，并且立刻返回这个真。而后面两个例子里，flip- flop的内部状态也被翻成了真，但在本次迭代的时候依然返回假，因为前面设置了^符号。

类似的，第一、三个例子里，右端为真即返回真；而第二、四个例子里，右端为真依然返回一次假。

如果想让flip-flop操作符flip之后不再flop回来。可以在右端使用*号：
    for 1..20 { .say if $_ == 15 ff *; }     # 15 16 17 18 19 20

Perl6中还有一种和上面类似的flip-flop操作符，唯一的不同就是在左端为真的时候并不评估右端的返回值。这一点在左右两端都为真的时候尤其重要。这种操作 符记为：fff、fff^、^fff和^fff^

来源： < https://github.com/sxw2k/perl6advent_cn/blob/master/chinese/2011/%E7%AC%AC%E4%BA%94%E5%A4%A9:%E7%BF%BB%E8%BD%AC%E6%93%8D%E4%BD%9C%E7%AC%A6.markdown >  