

我们都知道Perl5对Unicode的支持是非常好的（从5.8版开始，越来越好）。不过大家依然在抱怨难用。。。这里最重要的一个原因就是程序员们需要自己去跟踪 哪个字符串被解码了，哪个是二进制的。根本没有一个可靠的内省变量来区分字符串是二进制的还是文本格式的。

在Perl6里，这个问题终于解决了！我们引入了不同的类型。Str指的是文本字符串，而Buf对象则是存储二进制数据的。绝对不会有别的办法来混淆这两者。转换依然 是使用编码(encode)和解码(decode)方法。

    my $buf = Buf.new(0x6d, 0xc3, 0xb8, 0xc3, 0xbe, 0x0a);
    $*OUT.write($buf);
 
    my $str = $buf.decode('UTF-8');
    print $str;

这两个输出操作的结果是一样的。在标准输出上打印一个møþ并且换行。Buf.new()需要的参数是一个0到255之间的整数列表，用来构建新的字节缓冲区的字节的 具体数值。然后$*OUT.write($buf)把$buf缓冲写入标准输出。

$buf.decode('UTF-8')解码上面的缓冲，然后返回一个Str对象（当然也可能返回的是错误，比如缓冲根本不是用UTF- 8构建的）。对应的反向操作就是$buf.encode($encoding)。一个Str对象可以简单的用print输出。

事实上，在这个输出的过程中，print也需要把字符串转成二进制的表示。这里有一个默认的编码操作，不管是print还是其他的操作符都是 。而且这个编码统一都是UTF-8的。Perl6的规范中允许用户更改这个默认设置，不过目前为止，还没有哪个Perl6实现做到这点。

读入的时候，你可以使用.read($no-of-bytes)方法来读入一个Buf对象，然后.get方法来读入一行输入到Str对象。

这些读写方法，不单单在普通的文本和流处理上存在，在套接字处理时也能用。

在Perl5里，你可能不小心就做出这么件特别讨厌的事情：把文本和二进制字符串联结(concatenate)在一起，或者其他的类似的方式（比如join和字符串 插入）。这个操作的结果就是字符串被破坏了，但是前提是二进制字符串的长度大于127字节。。这可真是调试程序时的噩梦啊！

在Perl6里，如果还这么做，你会得到一个"Cannot use a Buf as a string"的警告。不用再担心这个陷阱了。

目前已有的Perl6编译器，还不能提供和Perl5相同水平的Unicode支持，但是至少这些字符不至于被误用了。

来源： < https://github.com/sxw2k/perl6advent_cn/blob/master/chinese/2011/%E7%AC%AC%E4%B8%89%E5%A4%A9:%E7%BC%93%E5%86%B2%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.markdown >  