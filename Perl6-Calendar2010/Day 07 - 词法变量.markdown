2010 年 Perl6 圣诞月历(七)词法变量

编程总是件很难持续做下去的事情。串几行代码很容易，根据想法做一个原型也是轻松愉快的。但随着程序慢慢变大，维护时间慢慢变长，事情慢慢就棘手起来了……最后，如果不幸的话，我们就得被迫重构——不是因为早先的问题复杂，而是因为程序本身复杂了……在不断的调试中急白了头的程序员们，早就不记得到底要怎么扩展程序以完成目的了……

所以我们回溯一下编程史，找找对着复杂性的办法。而答案就在那里，不来不去——限制长度。当你架构一个成百上千模块组成的大型程序的时候，你必须能够让这些组件通过表面上很小的设置进行交互——否则你就等着被乱七八糟的组合干死吧。

在各层次的编程上，我们都可以看到这么一个原则。因为他就只关心这一件事情：分散注意，专一的做一件事情！BCNF 范式、monads (译者注：不知道这东东咋翻译)、单子，例程，类，角色，模块，包等。这些都是在督促和指导我们限制编程的长度。这样我们才不会输在组合学上。而这方面最简单的例子，就是此法变量。

{
    my $var;
    # $var可见
}
# $var不可见

哈哈，这就是今天要介绍的一个非常酷的功能了！非常有趣的说~

Perl从第一版开始，在这方面一直不太对。比如Perl5的默认变量作用域是包。而这就是全局变量的一种。我在某个代码块里定义了一个变量，其他地方居然也能看到……

$ perl -v
This is perl 5, version 12, subversion 1 (v5.12.1)
$ perl -E '{ $var = 42 }; say $var'
42
$ perl -wE '{ my $var= 42 }; say $var'
Name "main::var" used only once: possible typo at -e line 1.
Use of uninitialized value $var in say at -e line 1.

在Perl6里，词法变量变成了默认设置。在 Rakudo 上运行上面的代码，根本无法通过编译：

$ perl6 -e '{ $var = 42 }; say $var'
===SORRY!===
Symbol '$var' not predeclared in <anonymous>
$ perl6 -e '{ my $var = 42 }; say $var'
===SORRY!===
Symbol '$var' not predeclared in <anonymous>

好了，你可能说：“嗯，可以减少点打错字的可能了”。这当然没错，但是更重要的是：这让你认真坦诚的对待变量作用域。这对你控制代码复杂性很有利！

我们可以说出很多很多解释来说明为啥 Perl5 这么做。比如 Perl5 已经建议大家 use warnings;use strict; ，比如 Perl5 承诺的向后兼容，嗯，很伟大的做法，而 Perl1 压根没打算用来写大型程序和管理带来的复杂性；比如全局变量在单行模式下的各种方便……

Perl6 内置的强制你从小处着手，帮你在系统扩容的时候，更苛责的关注架构基础。在变量方面，也就是在脚本和模块中，将词法变量作为默认设置。不过在 perl -e 执行的单行命令中，默认依然是全局变量。（ Rakudo 还没有实现这个，目前单行依然是词法变量，期待实现的那天~）

继续。好像到这里你感觉词法变量的价值已经说完了？没有！正确设计的结果可是令人惊讶和奖金源源不断啊~考虑一下这个子程序：

sub counter($start_value) {
    my $count = $start_value;
    return { $count++ };
}

这里返回的是一个代码块。所以每次我们调用 counter() 的时候，得到的都是一小片断开的代码。然后看看当我创建两片这样的代码后的结果：

my $c1 = counter(5);
say $c1();           # 5
say $c1();           # 6
&nbsp_place_holder;
my $c2 = counter(42);
say $c2();           # 42
say $c1();           # 7
say $c2();           # 43

看到了吧， $c1 和 $c2 是完全分开的，他们相互独立互不影响。尽管他们都写成 $count 的样子，看起来真是差不多，但他们都有自己独立的存储单元——因为每次我们运行进入那个代码块的时候，就是一次重新开始。这个小代码块从运行中的计数器里返回，这些计数器里保留了存储单元的对应关系。（他“关闭”这个存储单元，保护它不被 GC 回收掉。这类代码块叫闭包）

这个闭包看起来像是个轻量级的对象？gxgx，他们确实就是。闭包背后的原则，即规范对闭包值的访问方式，与面向对象背后的封装和信息的原则是一样的。他们都是尽力限制事情的程度，在事情变得糟糕的时候，帮忙减少其影响和损失。

你可以用词法变量做些很有趣的事情，比如闭包；而包变量不行。词法变量最酷啦！吼吼~~

来源： < https://github.com/sxw2k/perl6advent_cn/blob/master/chinese/2010/%E7%AC%AC%E4%B8%83%E5%A4%A9:%E8%AF%8D%E6%B3%95%E5%8F%98%E9%87%8F.markdown >  