

作者提示：笔者本人对线程基本没什么认识。任何问题都有可能发生。我只是测试用例，解决一些死锁，添加了一些cpu核数的代码然后合并线程分支到主分支而已。

Parrot 现在支持高速而且轻量级的操作系统线程，基于最初 Nat Tuck 的 GSoC 的工作，加上 Andrew 的 "白骑士"，Whitworth 的绿色线程，最后是 Stefan Seifert 的让并发操作系统线程变成超线程的补丁。详见 http://wknight8111.blogspot.co.at/2010/08/gsoc-threads-chandons-results.html and http://niner.name/Hybrid_Threads_for_the_Parrot_VM.pdf

过去几年，Parrot 一直就支持“线程”，比如说并发模型。不过我们给这个特定设计找到了各种问题，然后持续改进。在我们的用例中并没有修改太多的 API，因为 pdd25 并发规范已经是在很高级的层次上表述了 parrot 需要支持的各种模型，而且同样在很底层上描述了两种 PMC 的线程 API ，即 Task 和 Scheduler 类。

Parrot 的线程支持最初和 Perl 的 线程模型相当接近，因为跟现在比，那时候的 Perl6 也相当像 Perl5 。之前关于改成更传统的默认数据共享的模型，或者实现类似 STM “软件事务内存”这类新技术的尝试都失败了。比如 Parrot 一直没法同时支持多线程运行和垃圾回收。

2005 年，中央处理器(CPUs)的发展从提高单核速度转移到了增加更多核心。现代处理器已经有超过 12 核，哪怕手机都有 4 核了。要充分利用现代 CPU 的能力，代码需要并行。在 UNIX （因此包括 Perl）的传统里，大多数情况是可以通过启动多个进程来解决的。而其他的情况，比如 Perl6 里的 hyper 操作符是自动线程的，进程创建和通信的开销在大数据集的时候就非常大了。

在来回尝试给 Parrot 添加线程支持的失败的这几年里，Perl6 规范已经演变到一点，就是语言的最大部分已经完成，而它的特性需要在编译器里实现。Parrot 的并发原语的缺失，已经阻碍了在并发支持领域的全部进展。

绿色线程被用来简化一个接近无锁的多线程实现的实现。 http://niner.name/Hybrid_Threads_for_the_Parrot_VM.pdf

Parrot 现在支持原生的 Win32 线程和 POSIX 线程。Win32 上的 alarm ， sleep 和 premption 和 POSIX 上是统一的，由一个常见的定时器线程处理。

Parrot 启动时创建一个线程池，池内线程数量由 --numthreads 参数制定，默认值是 CPU 核心数。启动新线程不会有运行时损失，除非已经超过 CPU 核心数了。当用户开始一个新任务的时候i，调度器首先查找空闲线程。如果找到，任务被调度到这个线程的解释器。如果启动的任务数超过线程的最大数量，任务则均匀的分布到运行的解释器上。这是个有效的N:M 线程模型实现。 绿色线程

我们 GSOC 的学生 Nan "Chandor" Tuck 从 2010 年夏天开始开发绿色线程。

我现在在做的是一个 Parrot 的预先调度式的绿色线程系统，需要程序写成并发式的风格。这个绿色线程可以不停止其他运行的线程的情况下做基础的阻塞式的文件输入操作。这些逻辑线程通过我几个星期前刚表述过的 Task API 访问。这个功能让 Parrot 在线程方面和标准版本的 Ruby 或者 Python 一样强大。线程可以做几乎任何事情除了同时运行。 http://parrot.org/content/hybrid-threads-gsoc-project-results

这个绿色线程分支还欠缺的就是在操作系统线程上真正的并发执行，一个通过锁或者其他并发访问规则共享和保护的全局解析器结构，以及可以在不同操作系统线程中同时运行的多个本地解释器。 操作系统线程

2011 年秋天到 2012 年夏天，Stefan "nine" Seifert 在绿色线程的基础上实现了真正的操作系统县城，终于可以让任务真正的并发执行并且实现了阻塞 IO，这让 Perl6 比 Perl5 多了些优势。

轻量级的绿色线程用来在共享变量全部可读唯一线程可写的系统中扮演消息的角色。所以我们叫它混合线程。 为什么多线程支持这么难实现？

底层的编程语言比如 C 语言，只提供一些必需品，把防止数据损坏和同步数据的责任都交给了用户。而像 Perl6 这样的高级语言，则需要提供复杂和复合的数据类型，处理垃圾回收以及非常动态的对象系统。哪怕看起来很简单的方法调用也可能变得很复杂。在静态类型编程语言里，类的定义是不可变的。所以，调用一个对象的方法的步骤就是：确定这个对象的类，从这个类里获取需要的方法，然后调用。再次调用的时候都可以忽略前两步因为他们的结果不变。

在动态语言里，对象可以在运行时改变自己的类。类的继承链可以因为父类的添加删除发生改变。方法也可以在运行时加给类（或者对象），抑或删除。甚至怎么找到一个类的方法也是可变的。所以一个简略的方法调用结果是这么来的：

    ·  确定对象的类，
    ·  确定解析类方法的方法，
    ·  找到要被调用的方法，
    ·  调用方法。

这些步骤在每次方法调用的时候都要重复，因为结果每次都可能变了。在线程环境里，并发执行的线程可能在序列间甚至序列的步骤间就改变了底层的数据和元数据。所以，元数据在性能关键的区域必须引入锁来防止污染。

很多动态语言比如 Python 或者 Ruby 的解释器都是通过使用全局解释器锁（GIL）有效的序列化所有的操作从而处理这个问题。这是一个已经被证明可靠的办法，但是也就浪费了很多硬件潜力无法发挥。 Java

在 Java 里，用户负责解决并发问题。语言本身提供了像互斥锁一类的同步原语，不过解释器（Java 虚拟机，JVM）并不保护它提供的数据结构的一致性。类库提给用户专门为多线程场景设计的高级数据结构。

Java 1.1 版本的时候使用绿色线程来支持 Java 程序的多线程执行。绿色线程是由虚拟机（VM）仿真的线程，无法使用多核处理。1.2 版本引入了原生操作系统线程支持，现在这是 Java 多线程编程的标准办法。 Python

Python 运行时实现 CPython 使用了全局解释器锁（GIL）保护其内部一致性。无论何时解释器执行 Python 字节码，这是一个唯一锁。因为这个锁，任何时候只能有一个线程执行字节码，所以内建类型和对象模型也就隐式的安全了。这个缺点是 Python 代码无法使用多核能力。不过 I/O 操作和调用外部库是在 GIL 锁定之外执行的，所以在多路 I/O 复用线程的应用里，使用多线程依然可以得到性能的提升。

要并发的运行 Python 代码，可以使用多进程。多进程模块暴露的 API 和线程模块很类似。因为进程不能直接访问其他进程的内存，多进程模块提供了几种进程间通信方式：队列，管道和共享内存。 Parrot

Parrot 原先和线程相关的绝大多数代码已经被移除以提高性能。因为现有的线程支持是不可靠的，而且有着明显的缺陷。2011 年 9 月 21 日，最后一部分相关代码也通过合并 kill_threads 分支而去除了。

2010 年，Nat Tuck 在他的谷歌暑假实习时开始开发 green_threads 分支。这个特性用纯 PIR 做出了原型，然后在 Parrot 核心里实现。他已经完成了在简单用例里成功运行并且开始尝试操作系统线程支持，但是代码还没合并进主分支，他的实习就结束了。代码停留在那一直到 2011 年 threads 分支开始混合线程的开发。

在 Parrot 中，绿色线程被叫做任务。每个任务分配到固定数量的执行时间。执行时间后一个定时器回调给它设置标记，在每个分支操作执行后都会检查这个标记。因为解释器的状态在这个时间点是定义完好的，所以它的内部一致性也就达到了。垃圾回收也是如此处理。因为任务抢占只在用户级别的代码上完成，拉圾回收可以不受干扰的进行而不需要锁。因为用户级别的代码可以关闭调度，所以它可以保证原样通过临界区域。

调度器被实现为一个 PMC 类型。这允许用户派生 这个 PMC 的子类以便细粒度的控制调度策略。用户可以这样添加特性，比如给任务分配不同的优先级，或者实现能够把任务挂起、恢复。 共享数据

跨线程写入共享变量可能危及解释器的内部一致性。解决这个问题的传统办法是使用不同粒度的锁。细粒度的锁允许代码并行但是上锁解锁会拖累性能。它不单是增加指令计数和内存访问，而且还强制 CPU 核心间相互通信。哪怕一个看起来很简单的操作比如原子增加也会多花费两个数量级的时间。虽然使用多核可以降低这种损耗，但是它依然会影响到只有单线程运行的普通情况。

另一方面，粒度太粗的锁又会降低可扩展性和并发执行提高的性能。因为它迫使线程长时间等待锁变为可用状态。极端情况下，使用一个全局解释器锁有效的序列化所有运算可以给线程带来很多很多好处。

另一个和锁有关的问题是可能引入死锁。比如，两个函数 F1 和 F2 都通过锁保护来使用资源 A 和 B。如果 F1 先锁定了 A 然后试图 锁定 B，但同时 F2 已经锁定了 B 并准备锁定 A，程序这时候就僵住了。两个函数都在等待另一个释放资源，但这永远不会发生。在细粒度锁的情况下，这种问题发生的可能性迅速的增加。同时，当这个锁产生各种难以判断的问题的时候，还很容易错过。

针对这些问题，本文中实现的解决方案是完全回避他们，不允许写入共享变量。程序员（大多数情况下是编译器）必须在新建任务开始前声明一个所有共享变量组成的列表。然后解释器给这些变量创建代理对象供任务来访问数据。这些代理对象包含了原始对象的引用。他们使用这些引用来转发所有的读取函数给原始对象。而写入请求则返回运行时错误。

也就是说，所有数据都归创建他们的线程所有，只有所有者自己可以写入。其他线程都只有读取权限。

对于需要和他们的创建者以及其他线程通信的线程，他们依然需要写入共享变量。这就是绿色线程发挥作用的地方了。因为绿色线程是轻量级的，可以让线程新建一个任务单独来更新变量。在解释器上，这个任务被调度于专门管理这个变量。为了减少延时，这个任务会被标记为立刻执行。这个有数据的解释器会抢占当前运行的任务，然后执行新的写入任务。换句话说，有数据的解释器是写入数据到变量这个操作的接收者，而不是其他线程。 代理

代理是线程间的仲裁者。他们是线程访问其他线程数据的唯一通道，是用 Proxy PMC 类型实现的。

代理为所有函数都设置了默认实现。写入函数报出 cant_do_write_method 运行时异常。如果一个方法从目标解释器中返回一个 PMC，另一个代理对象必须创建和包裹它。这样它才能安全的返回给调用者。 Sub

Sub PMC 代表可执行的子例程。一个 Sub 不仅包含要执行的代码，还包含执行代码的上下文比如可见的全局变量和名字空间。如果一个到 Sub 的代理被创建和调用，代码会直接访问这个上下文因为他和代理的 Sub 本身属于相同的解释器。所以，像 get_global 这样的操作要从非代理的名字空间获取一个全局变量，而非代理的全局变量则被写入目标寄存器。因为这个是在原始 Sub 上执行调用的时候发生的，代理没法终断调用并为结果创建新的代理。

这就是为什么 Parrot_thread_create_proxy 不给 Sub 创建代理而是用 Parrot_thread_create_local_sub 来在线程解释器里创建副本并代理到所有 PMC 属性。 写入共享变量

和第五节中说过的一样，要写入共享变量，线程需要创建一个任务然后调度他到数据所有的解释器。一个示例任务如下：

    .sub write_to_variable
         .param pmc variable
         variable = 1
    .end

这是一个只有单参数的子例程。作为参数传递的变量就是任务需要写入的地方。在这个示例里，常量 1 将要写入变量。在 PIR 中，PMC 的任务被翻译成一个方法调用。这里是 set_integer_native 被调用来改变变量值。因为 PMC 是以引用形式传入的，他就是需要写入的原始变量。

创建这个任务的代码如下：

    1    write_task = new ['Task']
    2    setattribute write_task, 'code', write_to_variable
    3    setattribute write_task, 'data', shared_variable
    4    interp.'schedule_proxied'(write_task, shared_variable)

第一行创建新的任务对象。示例子例程用来设置任务的代码属性。 shared_variable 是给数据用的。这里， shared_variable 就是为了共享整数 PMC 创建的代理对象。解释器对象包括一个 schedule_proxied 方法，用来调度拥有原始变量的线程的 write_task 。

在示例里， schedule_proxied 用 Parrot_thread_create_local_task 检测任务参数的数据是不是一个代理对象。 Parrot_cx_schedule_immediate 然后用来尽快让拥有数据的解释器执行任务。

为了保护临界区域，抢占可以被关闭，这样临界区域可以不中断的运行：

    1 .sub swap_variables
    2     .param pmc a, b
    3     .local temp
    4     disable_preemption
    5     temp = a
    6     a = b
    7     b = temp
    8     enable_preemption
    9 .end 等待

使用任务来写入共享变量让这种操作本质上变成异步。这不是实现算法中一直需要的。比如，当共享变量是个锁，进程因为在他释放后尽快恢复运行。等待操作用来等待任务的完成。等待任务被添加进任务的等待者列表然后立刻抢占。当任务结束，等待者列表里所有的任务都被重新调度以便执行。因为在目标线程上为每个任务都准备了本地副本，运行的任务并不单单检查他自己的等待者而是所有的。

如果主线程里一个任务在等待另外一个线程中的任务结束，而且调度器的主线程队列里没有其他任务，只要没有僵死，主线程就会自动退出。为了防止这种意外的退出，所有的任务在被调度往其他线程的时候，都已经被加入调度器的外部任务列表。结束一个还有线程在运行的程序，必须使用一个明确的退出操作。 测试

初步的测试说明 Parrot 的性能和 Perl5 中优化过的实现是一个数量级的。

因为 Parrot 还没有给用户提供同步原语，锁只能被实现成使用一个只有主线程有权写入的共享变量。用本地信号实现来替换这个原生方法可能可以节约一点点运行时。 矩阵乘法的运行时比较

                singlethreaded  computation      multithreaded   computation
    1. run          28.522 s       19.530 s        17.543 s          8.478 s
    2. run          28.427 s       19.463 s        17.320 s          8.283 s
    3. run          28.200 s       19.235 s        17.489 s          8.473 s
    average         28.383 s       19.409 s        17.451 s          8.411 s

这个测试使用了 4 个线程来实现矩阵乘法。为简单起见，第二个矩阵只有一列。程序是用 Winxed 变成语言写的。Winxed 是一个底层语言，语法和 Javascript相似而且可能包含 PIR 代码区域。这让试验性代码的测试变得可能。完整的示例都写在 examples/threads/matrix_part.winxed 。

The program consists of the parts initialization, computation and verification. Computation is parallelized using four tasks each calculating one fourth of the result vector. Runtime is compared to a simple singlethreaded implementation. Run times were measured using the time command and are recorded in the above table. 程序需要初始化变量，计算和认证。计算是并行起了4个任务且每个计算四个任务的结果。运行时被用来和简单的单线程实现作对比。见上图。

As can be seen, the multithreaded implementation gives an average speedup of 2.31 for the computation and 1.61 in total. 正如你看到的，多线程实现给计算加上了平均 2.31 ，总共1.61的速度。 为Mandelbrot的计算器作运行时比较

                 singlethreaded  1 thread    2 threads   4 threads    8 threads
    1. run           89.931 s    89.978 s    45.813 s     24.028 s     17.445 s
    2. run           89.707 s    89.871 s    45.906 s     24.048 s     17.695 s
    3. run           90.318 s    89.839 s    45.951 s     24.049 s     17.573 s
    average          89.985 s    89.896 s    45.890 s     24.042 s     17.571 s
    speedup           1.000        1.001       1.959       3.739        5.116

源代码见 examples/pir/mandel.pir

计算 Mandelbrot 集群的图像是一个多线程实现的普通的测试，因为各个计算点是相互独立的，可以很容易的并行。一个简单的逃逸时间算法的实现是用 Winxed 写的。可以用来确定线程实现的扩展属性。图像被切开成数行，这也是被配置好的数量的任务自动计算的。运行时间是通过在 Intel Core i7 3770K 处理器和 16 GiB 内存，运行 openSUSE 12.1的设备上使用 time 命令测试出来的，然后计入进 Mandelbrot 表。如你所见，这个实现扩展到四个线程对应四个物理核心。使用 8 线程，只提高了 1.368 倍。不过这个更像是硬件限制而不是实现的问题。 问题

详细问题可以在 IRC 或者邮件列表里询问。

更多内容见： http://lists.parrot.org/pipermail/parrot-dev/2012-December/007295.html

来源： < https://github.com/sxw2k/perl6advent_cn/blob/master/chinese/2012/%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9:Parrot%E7%BA%BF%E7%A8%8B.markdown >  